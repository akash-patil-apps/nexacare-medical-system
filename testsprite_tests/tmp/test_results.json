[
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "ac42091a-d192-4982-b256-87e3d2d7c098",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC001-Password-based Authentication Success",
    "description": "Verify that users with valid credentials can authenticate successfully using password login, receive a valid JWT token, and access the appropriate role-based dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input valid username and password into the login form.\n        frame = context.pages[-1]\n        # Input valid mobile number as username\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input valid password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        # -> Submit the login form by clicking the Sign In button.\n        frame = context.pages[-1]\n        # Click the Sign In button to submit the login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid username and password again and submit the login form.\n        frame = context.pages[-1]\n        # Input valid mobile number as username\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input valid password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click the Sign In button to submit the login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify the presence and validity of the JWT token in browser storage to confirm successful authentication.\n        frame = context.pages[-1]\n        # Open user menu or settings to check for token or session info if available\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/div[3]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=NexaCare Hospital').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Hospital Admin 1').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=HOS-2026-002').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Apollo Hospitals Mumbai').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Active Hospital Admin').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Total Doctors').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=20').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Total Patients').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=8').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Upcoming Appointments').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=5').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Monthly Revenue').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â‚¹0').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pending:').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=6').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Confirmed:').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=13').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Completed:').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=0').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Total:').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=28').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=0 of 5 completed today').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Appointments').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=IPD Management').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Upcoming Appointments').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=View All').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Today (5)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pending (0)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Confirmed (0)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Checked In (5)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=In Consultation (0)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Completed (0)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Suresh Iyer').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=07 Jan 2026').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=#1').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Dr. Uma Chopra').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Dermatology').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CHECKED-IN').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that users with valid credentials can successfully authenticate and receive a JWT token. However, the last action of inputting the valid mobile number as the username failed due to a timeout error. Specifically, the error message indicates that the locator for the input field could not be found within the specified timeout period of 30 seconds. This suggests that the element may not be present in the DOM at the time the script attempted to interact with it, possibly due to the page not being fully loaded or the locator being incorrect. As a result, the authentication process could not proceed, leading to the failure of the overall task.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767782435104497//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.224Z",
    "modified": "2026-01-07T10:40:35.250Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "7555c82e-071c-48b8-a3a0-e73d983ce373",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC002-OTP-based Authentication Success",
    "description": "Ensure users can authenticate using OTP login flow and receive valid JWT tokens with correct role assignments.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the OTP Login tab to switch to OTP login form.\n        frame = context.pages[-1]\n        # Click on OTP Login tab to switch to OTP login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the mobile number input field first to focus, then input the mobile number '9810000000'.\n        frame = context.pages[-1]\n        # Click on mobile number input field to focus it before typing\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the OTP Login tab (index 4) to switch to OTP login form, or if not possible, report the issue and stop.\n        frame = context.pages[-1]\n        # Click on OTP Login tab to switch to OTP login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input the registered mobile number '9810000000' into the mobile number input field.\n        frame = context.pages[-1]\n        # Input registered mobile number for OTP request\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div[2]/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        # -> Click the 'Send OTP' button (index 8) to request the OTP.\n        frame = context.pages[-1]\n        # Click the Send OTP button to request OTP for the entered mobile number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div[2]/div/form/div[2]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Authentication Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: OTP login flow did not complete successfully, valid JWT token was not received, or user did not access the correct role-based dashboard as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that users can authenticate using the OTP login flow and receive valid JWT tokens with correct role assignments. However, the last action of clicking on the OTP Login tab failed due to a timeout error. Specifically, the error message indicates that the locator for the OTP Login tab could not be found within the specified timeout of 5000 milliseconds. This suggests that either the element is not present in the DOM at the time of the click attempt, or the XPath used to locate the element is incorrect or outdated. \n\nTo resolve this issue, you should:\n1. Verify that the OTP Login tab is indeed present on the page when the click action is attempted.\n2. Check if the XPath used to locate the element is correct and corresponds to the current structure of the page.\n3. Consider increasing the timeout duration or implementing a wait condition to ensure the element is fully loaded before attempting to click it.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767782397222378//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.233Z",
    "modified": "2026-01-07T10:39:57.328Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "ebf2f913-3fff-463a-8cc6-82aba860dee2",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC003-Login Failure with Incorrect Credentials",
    "description": "Validate system behavior when login attempts use invalid password or OTP, ensuring no token is granted and error messages appear.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input invalid username and password into the respective fields\n        frame = context.pages[-1]\n        # Input invalid username/mobile number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input invalid password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        # -> Submit the login form by clicking the Sign In button\n        frame = context.pages[-1]\n        # Click the Sign In button to submit the login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Login attempt with invalid credentials was rejected as expected, but the test plan execution has failed.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to validate the system's behavior when invalid login credentials are used, specifically ensuring that no token is granted and appropriate error messages are displayed. However, during the last action of inputting an invalid username or mobile number, a timeout error occurred. This indicates that the script was unable to locate the input field within the specified time limit (30 seconds). \n\nThe error message states: 'Locator.fill: Timeout 30000ms exceeded', which means that the locator for the input field was not found on the page, possibly due to the element not being rendered yet, an incorrect XPath, or the page not being in the expected state. As a result, the action to fill in the invalid username failed, leading to the overall failure of the test case. \n\nTo resolve this issue, you should:\n1. Verify the XPath used for locating the input field to ensure it is correct and matches the current page structure.\n2. Check if the page has fully loaded before attempting to interact with the input fields.\n3. Consider adding a wait condition to ensure the element is present before trying to fill it.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767782443299248//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.238Z",
    "modified": "2026-01-07T10:40:43.443Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "17091d2e-20b9-4247-a4d0-3b5bc8f690be",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC004-Role-based Route Protection",
    "description": "Verify that users cannot navigate to dashboards or pages not permitted for their role, enforcing authorization.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and password, then click Sign In to login as Patient user\n        frame = context.pages[-1]\n        # Enter mobile number for Patient user\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Enter password for Patient user\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access to Doctor or Admin dashboard is granted').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User was able to access a restricted dashboard despite role-based authorization enforcement.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that users cannot access unauthorized dashboards or pages based on their roles. However, during the last action of entering the mobile number for the Patient user, an error occurred. The error message indicates that the locator for the mobile number input field timed out after 30 seconds, meaning the script could not find the specified element on the page within the allotted time. \n\nThis timeout could be due to several reasons: \n1. **Element Not Present**: The mobile number input field may not be present on the current page, possibly due to a navigation issue or a change in the page structure.\n2. **Incorrect Locator**: The XPath used to locate the input field might be incorrect or outdated, leading to the inability to find the element.\n3. **Page Load Issues**: The page may not have fully loaded before the script attempted to interact with the element, causing the locator to fail.\n\nTo resolve this issue, verify the presence of the mobile number input field on the current page, check the accuracy of the XPath, and ensure that the page has fully loaded before attempting to fill in the input.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767782440711362//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.244Z",
    "modified": "2026-01-07T10:40:40.858Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "63346706-155e-4609-a132-399410905485",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC005-Patient Appointment Booking Flow",
    "description": "Test full patient appointment workflow: searching hospital and doctor, selecting time slot, booking appointment, receiving confirmation, and viewing appointment status.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and password, then click Sign In button\n        frame = context.pages[-1]\n        # Input mobile number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry login or try OTP login tab\n        frame = context.pages[-1]\n        # Click OTP Login tab to try alternative login method\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input mobile number and click Send OTP button\n        frame = context.pages[-1]\n        # Input mobile number for OTP login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div[2]/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div[2]/div/form/div[2]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Appointment Successfully Completed').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The full patient appointment workflow did not complete successfully as expected. The appointment was not created, confirmed, or updated properly according to the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to complete the full patient appointment workflow, which includes inputting a mobile number and password, followed by clicking the Sign In button. However, during the last step of inputting the mobile number, an error occurred. The error message indicates that the locator for the mobile number input field timed out after 30 seconds, meaning the script was unable to find the specified element on the page within the allotted time.\n\nThis timeout could be due to several reasons:\n1. **Element Not Present**: The mobile number input field may not be present on the page at the time the script attempted to access it. This could happen if the page has not fully loaded or if there is a change in the DOM structure.\n2. **Incorrect Locator**: The XPath used to locate the input field might be incorrect or outdated, especially if there have been changes to the page layout or structure.\n3. **Timing Issues**: The script may be executing too quickly, not allowing enough time for the page to render the input field.\n\nTo resolve this issue, consider the following steps:\n- Verify that the mobile number input field is indeed present on the page by checking the current page's HTML structure.\n- Update the XPath locator if necessary to ensure it accurately points to the input field.\n- Implement additional wait strategies, such as waiting for specific elements to be visible or using explicit waits, to ensure the page is fully loaded before attempting to interact with elements.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767782439275577//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.251Z",
    "modified": "2026-01-07T10:40:39.421Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "0b02bf00-ae6c-4774-8e6f-cead4c7fccd0",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC006-Appointment Time Slot Booking Edge Cases",
    "description": "Verify system properly handles booking attempts on already occupied or invalid time slots and limits booking to allowed times.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and password, then click Sign In to login as patient.\n        frame = context.pages[-1]\n        # Input mobile number for patient login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input password for patient login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login as patient\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Doctors page to select a doctor for booking.\n        frame = context.pages[-1]\n        # Click on 'Doctors' menu item to view list of doctors\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/ul').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Booking Successful! Your appointment is confirmed.').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Booking attempts on already occupied or invalid time slots were not properly handled. The system should reject such bookings with appropriate error messages as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that the system properly handles booking attempts on already occupied or invalid time slots. However, during the last action of inputting the mobile number for patient login, an error occurred. The error message indicates that the locator for the mobile number input field could not be found within the specified timeout period (30 seconds). This suggests that the input field may not be present on the page at the time the action was attempted, possibly due to a delay in loading the page or a change in the page structure that made the locator invalid. As a result, the subsequent actions, including inputting the password and clicking the Sign In button, could not be executed, leading to the overall failure of the login process. To resolve this, ensure that the page is fully loaded and that the locator is correct before attempting to fill in the input fields.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767782417476931//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.257Z",
    "modified": "2026-01-07T10:40:17.615Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "a3ccf995-415e-4ccd-b188-8d956e16d249",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC007-Digital Prescription Creation and Viewing",
    "description": "Verify doctors can create and save prescriptions linked to appointments and that patients can view and download their prescriptions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input doctor credentials and sign in.\n        frame = context.pages[-1]\n        # Input doctor mobile number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input doctor password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login as doctor\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Appointments section to select a patient's confirmed appointment.\n        frame = context.pages[-1]\n        # Click on 'Appointments' menu item to view appointments\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/ul/li[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'View All' button under Upcoming Appointments to access appointments list.\n        frame = context.pages[-1]\n        # Click 'View All' button under Upcoming Appointments to view full appointments list\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/main/div/div[4]/div/div[2]/div/div/div/div/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Appointments' menu item to access the appointments page and look for confirmed appointments.\n        frame = context.pages[-1]\n        # Click on 'Appointments' menu item to navigate to appointments page\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/ul/li[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'View All' button under Upcoming Appointments again to access the full appointments list or try to click on one of the listed appointments directly.\n        frame = context.pages[-1]\n        # Click 'View All' button under Upcoming Appointments to view full appointments list\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/main/div/div[4]/div/div[2]/div/div/div/div/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click on the first appointment row (Suresh Iyer) to open appointment details\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/main/div/div[4]/div/div[2]/div/div/div/div/div/div[2]/div/div/div[2]/div/div/div/div/div/div/div/div/div/div/div/div[2]/table/tbody/tr[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Prescription Created Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to verify that doctors can create and save prescriptions linked to appointments and that patients can view and download their prescriptions.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767781213906733//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.264Z",
    "modified": "2026-01-07T10:39:18.222Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "ea2060af-2d9e-4d41-a7d3-1ea0e55d2072",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC008-Lab Test Request and Report Upload Workflow",
    "description": "Test lab technician and doctor interactions: lab test request creation by doctor, sample processing by lab technician, report upload, and status notifications to patient and doctor.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input Doctor credentials and sign in\n        frame = context.pages[-1]\n        # Input Doctor mobile number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input Doctor password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login as Doctor\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Lab Test Report Successfully Uploaded').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: Lab test request creation, sample processing, report upload, and notifications did not complete successfully.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767781068297947//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.270Z",
    "modified": "2026-01-07T10:39:18.228Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "726707d7-42ca-4f24-bdea-b36513d4cda5",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC009-OPD Queue Management and Patient Check-in",
    "description": "Verify receptionist can manage OPD queue by confirming appointments, registering walk-ins, calling next patient, and updating queue status real-time to all dashboards.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and password, then click Sign In button to login as Receptionist\n        frame = context.pages[-1]\n        # Input mobile number for receptionist login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input password for receptionist login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login as Receptionist\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Appointments section to confirm patient appointments for the day\n        frame = context.pages[-1]\n        # Click on Appointments menu to manage appointments\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/ul/li[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to click the 'View All' button in the Upcoming Appointments section to see full appointments list for confirmation\n        frame = context.pages[-1]\n        # Click 'View All' button in Upcoming Appointments section to view full appointments list\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/main/div/div[4]/div/div[2]/div/div/div/div/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Patients or Appointments tab to find option to register walk-in patients to the queue\n        frame = context.pages[-1]\n        # Click on Patients menu to check for walk-in registration option\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/ul/li[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Appointment Confirmed Successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Receptionist could not manage OPD queue as expected. The appointment confirmation, walk-in registration, calling next patient, or real-time queue updates did not occur as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to enable the receptionist to manage the OPD queue by logging in successfully. However, the last action of inputting the mobile number failed due to a timeout error. Specifically, the locator for the mobile number input field could not be found within the specified time (30 seconds). This indicates that either the element is not present on the page, the XPath used to locate it is incorrect, or the page has not fully loaded before the action was attempted. As a result, the login process could not proceed, preventing the receptionist from accessing the necessary functionalities to manage the OPD queue.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767782438941782//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.276Z",
    "modified": "2026-01-07T10:40:39.062Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "6f24ceb7-0d3d-4778-b195-e2e3eb332a8b",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC010-IPD Patient Management: Vitals Recording and Nursing Notes",
    "description": "Ensure nurses can record patient vitals, input nursing notes, monitor patient status, and view documentation efficiently within IPD workflow.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input nurse mobile number and password, then click Sign In button\n        frame = context.pages[-1]\n        # Enter nurse mobile number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Enter nurse password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Sign In button to login as Nurse\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Re-enter nurse mobile number and password, then click Sign In button\n        frame = context.pages[-1]\n        # Re-enter nurse mobile number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Re-enter nurse password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'IPD Management' tab to access admitted IPD patients list\n        frame = context.pages[-1]\n        # Click on IPD Management tab\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/main/div/div[4]/div/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate and select an admitted IPD patient to proceed with recording vitals and nursing notes\n        await page.mouse.wheel(0, 300)\n        \n\n        frame = context.pages[-1]\n        # Click on Patients menu to find admitted IPD patients\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/ul/li[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Patient Discharge Summary').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to verify that nurses can record patient vitals, input nursing notes, monitor patient status, and view documentation efficiently within the IPD workflow.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767781168616935//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.281Z",
    "modified": "2026-01-07T10:39:18.240Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "357cad20-31ad-4583-8729-78085a74952d",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC011-Real-Time Notification System Functionality",
    "description": "Verify that all notification types (appointments, lab reports, prescriptions, queue calls) trigger in-app alerts, sound notifications, visual indicators, and cross-tab synchronization.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and password, then click Sign In to log in.\n        frame = context.pages[-1]\n        # Input mobile number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify if OTP login tab can be used or if there is any other way to login successfully.\n        frame = context.pages[-1]\n        # Click OTP Login tab to try alternative login method\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input mobile number 9810000000 and click Send OTP to initiate OTP login.\n        frame = context.pages[-1]\n        # Input mobile number for OTP login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div[2]/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div[2]/div/form/div[2]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Notification Success! All alerts triggered')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Notification types (appointments, lab reports, prescriptions, queue calls) did not trigger in-app alerts, sound notifications, visual indicators, or cross-tab synchronization as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767781121469855//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.288Z",
    "modified": "2026-01-07T10:39:18.246Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "f07b7783-5a43-48fa-88fe-88c35b9ab108",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC012-Responsive UI Across Devices and Screen Sizes",
    "description": "Test system UI responsiveness and usability on various screen sizes including desktop, tablet, and mobile devices ensuring consistent user experience using Ant Design system.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input login credentials and sign in to access dashboard for layout verification.\n        frame = context.pages[-1]\n        # Enter mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Enter password for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=UI layout broken on all devices').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The system UI responsiveness and usability test did not pass. The layout and navigation did not adapt correctly across desktop, tablet, and mobile screen sizes as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767781059169369//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.294Z",
    "modified": "2026-01-07T10:39:18.253Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "365c13de-da4e-4b63-a7f8-257876ea38a8",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC013-Database Schema Data Integrity and Relations Enforcement",
    "description": "Validate that database constraints, relations (foreign keys), and validation schemas prevent invalid or corrupted data insertion across core entities like users, appointments, prescriptions, and lab reports.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and password, then click Sign In to authenticate user\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to appointment creation or management page to test insertion with invalid patient or doctor user IDs\n        frame = context.pages[-1]\n        # Click link or button to navigate to main dashboard or menu after login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div[3]/span/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'I manage a Hospital' button (index 4) to proceed to hospital management role and access appointment or related management pages\n        frame = context.pages[-1]\n        # Click 'I manage a Hospital' to proceed with hospital management role\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Send OTP' button at index 13 to proceed with hospital admin account creation\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to proceed with hospital admin account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in all required fields with valid data and click 'Send OTP' to proceed with hospital admin account creation\n        frame = context.pages[-1]\n        # Input full name for hospital admin account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Admin')\n        \n\n        frame = context.pages[-1]\n        # Input email address for hospital admin account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[2]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@testhospital.com')\n        \n\n        frame = context.pages[-1]\n        # Input mobile number for hospital admin account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[3]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input password for hospital admin account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[4]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Confirm password for hospital admin account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to proceed with hospital admin account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Send OTP' button to proceed with OTP verification and continue hospital onboarding\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to proceed with hospital admin account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try alternative approach to input password, such as clicking the field first or using keyboard input, then input text. If unsuccessful, ignore password field input and proceed to click 'Send OTP' to test validation behavior.\n        frame = context.pages[-1]\n        # Click password input field to focus\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[4]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input password into password field after focusing\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[4]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Input confirm password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to proceed with hospital admin account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Refill all required fields with valid data carefully and click 'Send OTP' again to proceed with hospital admin account creation\n        frame = context.pages[-1]\n        # Re-input full name for hospital admin account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Admin')\n        \n\n        frame = context.pages[-1]\n        # Re-input email address for hospital admin account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[2]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@testhospital.com')\n        \n\n        frame = context.pages[-1]\n        # Re-input mobile number for hospital admin account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[3]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invalid Foreign Key Constraint Violation').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Database constraints, relations (foreign keys), and validation schemas did not prevent invalid or corrupted data insertion across core entities like users, appointments, prescriptions, and lab reports as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767781460190353//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.308Z",
    "modified": "2026-01-07T10:39:18.258Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "7a120090-f155-496b-a11f-7926c4963089",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC014-Performance: API and UI Response Time within Operational Thresholds",
    "description": "Ensure critical API endpoints and UI page loads meet defined maximum response times under normal load.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and password, then click Sign In to measure login API response time.\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        # -> Click Sign In button to submit login form and measure login API response time.\n        frame = context.pages[-1]\n        # Click Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Clear and re-input mobile number and password, then click Sign In again to trigger login API and measure response time.\n        frame = context.pages[-1]\n        # Clear mobile number input field\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Clear password input field\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Re-input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Re-input password for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Sign In button to submit login form and measure login API response time.\n        frame = context.pages[-1]\n        # Click Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Re-input mobile number and password carefully ensuring no validation errors, then click Sign In to trigger login API and measure response time.\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Measure API response time for appointment booking endpoint under normal load.\n        frame = context.pages[-1]\n        # Click on Appointments menu to access appointment booking features\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/ul/li[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=API Response Time Exceeded Limit').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Critical API endpoints and UI page loads did not meet the defined maximum response times under normal load as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that the critical API endpoints and UI page loads meet defined maximum response times under normal load. However, during the last action of inputting the mobile number for login, an error occurred. The specific error message indicates that the locator for the mobile number input field timed out after 30 seconds, meaning the script was unable to find the input element within the specified time frame.\n\nThis timeout could have occurred for several reasons:\n1. **Element Not Present**: The input field may not have been rendered on the page when the script attempted to access it, possibly due to slow loading times or a failure in the previous steps.\n2. **Incorrect Locator**: The XPath used to locate the input field might be incorrect or too specific, leading to the element not being found.\n3. **Page State**: The page may not have been in the expected state (e.g., not fully loaded or in a different state due to a prior action) when the script tried to interact with it.\n\nTo resolve this issue, you should:\n- Verify that the input field is present on the page and correctly identified by the XPath.\n- Consider adding a wait condition to ensure the element is visible and interactable before attempting to fill it.\n- Check for any potential issues with the page loading that could affect the availability of the input fields.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767782416842995//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.314Z",
    "modified": "2026-01-07T10:40:16.959Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "fc1ab471-749c-4e58-8d08-001a124d24ad",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC015-User Onboarding Flow Completion for Each Role",
    "description": "Validate the multi-step onboarding process for all user roles ensuring profile completion, verification, and role assignment before access to features.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Register here' to start new user registration for Patient role.\n        frame = context.pages[-1]\n        # Click on 'Register here' button to start registration\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div[3]/span/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'I manage a Hospital' role button which is active to proceed with onboarding for a selectable role.\n        frame = context.pages[-1]\n        # Click on 'I manage a Hospital' button to start onboarding for Hospital Admin role\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the 'Full Name', 'Email', 'Mobile Number', 'Password', and 'Confirm Password' fields with valid test data and click 'Send OTP' to proceed to OTP verification.\n        frame = context.pages[-1]\n        # Input Full Name for Hospital Admin\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Admin')\n        \n\n        frame = context.pages[-1]\n        # Input Email address for Hospital Admin\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[2]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testadmin@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input Mobile Number for Hospital Admin\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[3]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input Password for Hospital Admin\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[4]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Input Confirm Password for Hospital Admin\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to send OTP and proceed to verification step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to input Email address using alternative method or focus and clear the field before inputting text again, then proceed with OTP sending.\n        frame = context.pages[-1]\n        # Click on Email input field to focus\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[2]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Try inputting Email address again after focusing\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[2]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testadmin@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to send OTP and proceed to verification step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to focus Confirm Password field, clear it if needed, and input the password again. Then click 'Send OTP' to proceed.\n        frame = context.pages[-1]\n        # Focus Confirm Password input field\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input Confirm Password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to send OTP and proceed to verification step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to clear Confirm Password field by clicking and sending backspace keys, then input Confirm Password again. If still fails, report issue and proceed with other roles.\n        frame = context.pages[-1]\n        # Focus Confirm Password input field\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Clear Confirm Password field by sending backspaces\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08')\n        \n\n        frame = context.pages[-1]\n        # Input Confirm Password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to send OTP and proceed to verification step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in Full Name, Email, Mobile Number, Password, and Confirm Password fields with valid matching data and click 'Send OTP' to proceed to OTP verification.\n        frame = context.pages[-1]\n        # Input Full Name\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Admin')\n        \n\n        frame = context.pages[-1]\n        # Input Email\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[2]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testadmin@example.com')\n        \n\n        frame = context.pages[-1]\n        # Focus Mobile Number field\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[3]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input Mobile Number\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[3]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input Password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[4]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Input Confirm Password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div/div/div[5]/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click 'Send OTP' button to send OTP and proceed to verification step\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Onboarding Completed Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: The multi-step onboarding process did not complete successfully for all user roles, including profile completion, verification, and role assignment before access to features.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/1767781531389035//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.320Z",
    "modified": "2026-01-07T10:39:18.271Z"
  },
  {
    "projectId": "bd297af7-39eb-4e5f-9d70-aef58d91cbe0",
    "testId": "f1b2172f-1473-4845-8e08-c1e0a00eb736",
    "userId": "34a8a498-80f1-70f7-1227-36afd1c17ab9",
    "title": "TC016-Billing System: Invoice Generation and Payment Processing",
    "description": "Test invoice creation for appointments and services, process payments, and verify billing records update correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and password, then click Sign In to log in.\n        frame = context.pages[-1]\n        # Input the mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click the Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try switching to OTP Login tab to attempt login via OTP method.\n        frame = context.pages[-1]\n        # Click OTP Login tab to switch login method\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input mobile number 9810000000 into OTP login field and click Send OTP button.\n        frame = context.pages[-1]\n        # Input mobile number for OTP login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div[2]/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        # -> Try login again using password method by inputting mobile number and password, then clicking Sign In.\n        frame = context.pages[-1]\n        # Input the mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9810000000')\n        \n\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[2]/div/div[2]/div/div/span/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click the Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/div/div/div/div/div/div[2]/div/div/div/form/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate a completed appointment requiring billing by navigating to the Completed appointments tab.\n        frame = context.pages[-1]\n        # Click on Completed tab to view completed appointments\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/main/div/div[4]/div/div[2]/div/div/div/div/div/div[2]/div/div/div/div/div/div[6]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate a completed appointment requiring billing by navigating to Appointments tab and creating or marking an appointment as completed.\n        frame = context.pages[-1]\n        # Click on Appointments tab to manage appointments\n        elem = frame.locator('xpath=html/body/div/div/div/div/aside/div/div/ul/li[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate completion of an appointment by interacting with one of the checked-in appointment rows to mark it as completed.\n        frame = context.pages[-1]\n        # Click on first checked-in appointment row to open details or options for marking as completed\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/main/div/div[4]/div/div[2]/div/div/div/div/div/div[2]/div/div/div[2]/div/div/div/div/div/div/div/div/div/div/div/div[2]/table/tbody/tr[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invoice Payment Confirmation').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Invoice creation, payment processing, or billing record update did not complete successfully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a8a498-80f1-70f7-1227-36afd1c17ab9/17677813182109//tmp/test_task/result.webm",
    "created": "2026-01-07T10:14:48.326Z",
    "modified": "2026-01-07T10:39:18.277Z"
  }
]
